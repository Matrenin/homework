	Асинхронность - это операции, которые последовательно берутся из стека вызовов. В JavaScript нет многопоточности, это значит, что код выполняется линейно и последовательно, а не параллельно. Удалить операцию из стека нельзя, можно только прервать поток выполнения. Асинхронные операции выполняются не в движке, а в окружении.

	Стек вызовов — это структура данных, которая, записывает сведения о месте в программе, где мы находимся.

	Во-первых, promise выполняется с объектом встроенного класса Response в качестве результата, как только сервер пришлёт заголовки ответа.
	
	Во-вторых, для получения тела ответа нам нужно использовать дополнительный вызов метода. Response предоставляет несколько методов, основанных на промисах, для доступа к телу ответа в различных форматах: response.text(), respons.json() и т.д. Мы можем выбрать только один метод чтения ответа. Если мы уже получили ответ с response.text(), тогда response.json() не сработает, так как данные уже были обработаны.

	Протокол – это набор правил, описывающих, в каком виде передаются и принимаются данные. Чаще всего используется протокол HTTP.

	AJAX – это набор инструментов для работы с сервером без перезагрузки страницы. При использовании AJAX, запрос к серверу не блокирует страницу и не перезагружает её. Получив ответ, приложение может обновить отдельный компонент страницы.

	Promise –это объект, представляющий результат успешного или неудачного завершения асинхронной операции. это специальный объект, который находится в одном из трёх состояний: ожиданиe, выполнено успешно и  выполнено с ошибкой. При создании промиса нужно указать два колбэка – для успешного выполнения и для ошибки.

	Очередь задач(callBack queue) 
Среда выполнения JavaScript содержит очередь задач. Эта очередь — список задач, подлежащих обработке. Каждая задача ассоциируется с некоторой функцией, которая будет вызвана, чтобы обработать эту задачу. Когда стек полностью освобождается, самая первая задача извлекается из очереди и обрабатывается. Обработка задачи состоит в вызове  ассоциированной с ней функции с параметрами, записанными в этой задаче. Как обычно, вызов функции создаёт новый контекст выполнения и заносится в стек вызовов.

	Если очередной then вернул промис, то далее по цепочке будет передан не сам этот промис, а его результат.













